/**
 * Script to regenerate tag-type-union.ts and tag-interface-union.ts
 * by scanning all tag files in src/tags/ and extracting enums and interfaces.
 */

import { walk } from "https://deno.land/std@0.224.0/fs/walk.ts";
import { relative, dirname } from "https://deno.land/std@0.224.0/path/mod.ts";

interface CategoryData {
  folder: string;
  enumTypes: string[];
  interfaces: string[];
}

/**
 * Parse a TypeScript file to extract exported enum types and interface names
 */
function parseTagFile(content: string): { enumTypes: string[]; interfaces: string[] } {
  const enumTypes: string[] = [];
  const interfaces: string[] = [];

  // Match: export enum TagType...
  const enumRegex = /export\s+enum\s+(TagType\w+)/g;
  let match;
  while ((match = enumRegex.exec(content)) !== null) {
    enumTypes.push(match[1]);
  }

  // Match: export interface Tag... (but not ...Base)
  const interfaceRegex = /export\s+interface\s+(Tag\w+)/g;
  while ((match = interfaceRegex.exec(content)) !== null) {
    const interfaceName = match[1];
    // Skip interfaces ending with "Base"
    if (!interfaceName.endsWith("Base")) {
      interfaces.push(interfaceName);
    }
  }

  return { enumTypes, interfaces };
}

/**
 * Scan all tag files and organize by category
 */
async function scanTagFiles(): Promise<Map<string, CategoryData>> {
  const tagsDir = "./src/tags";
  const categoryMap = new Map<string, CategoryData>();

  for await (const entry of walk(tagsDir, { 
    exts: [".ts"],
    includeDirs: false,
  })) {
    // Skip index.ts files
    if (entry.name === "index.ts") continue;

    const content = await Deno.readTextFile(entry.path);
    const { enumTypes, interfaces } = parseTagFile(content);

    // Get category folder (first level subdirectory)
    const relativePath = relative(tagsDir, entry.path);
    const folder = relativePath.split("/")[0];

    if (!categoryMap.has(folder)) {
      categoryMap.set(folder, {
        folder,
        enumTypes: [],
        interfaces: [],
      });
    }

    const categoryData = categoryMap.get(folder)!;
    categoryData.enumTypes.push(...enumTypes);
    categoryData.interfaces.push(...interfaces);
  }

  return categoryMap;
}

/**
 * Generate tag-type-union.ts content
 */
function generateTagTypeUnion(categories: Map<string, CategoryData>): string {
  const sortedCategories = Array.from(categories.values()).sort((a, b) =>
    a.folder.localeCompare(b.folder)
  );

  let content = "// This file is auto-generated by script/generate-unions.ts\n";
  content += "// Do not edit manually - run 'bun run sync-unions' to regenerate\n\n";

  // Generate imports
  for (const category of sortedCategories) {
    if (category.enumTypes.length === 0) continue;

    content += `import {\n`;
    for (const enumType of category.enumTypes.sort()) {
      content += `  ${enumType},\n`;
    }
    content += `} from "./tags/${category.folder}/index.js";\n`;
  }

  content += "\n/**\n * All kind of unique tags defined.\n */\n";
  content += "export type TagType =\n";

  // Generate union
  const allEnumTypes: string[] = [];
  for (const category of sortedCategories) {
    allEnumTypes.push(...category.enumTypes);
  }

  allEnumTypes.sort();
  for (let i = 0; i < allEnumTypes.length; i++) {
    const prefix = i === 0 ? "  " : "  | ";
    const suffix = i === allEnumTypes.length - 1 ? ";" : "";
    content += `${prefix}${allEnumTypes[i]}${suffix}\n`;
  }

  return content;
}

/**
 * Generate tag-interface-union.ts content
 */
function generateTagInterfaceUnion(categories: Map<string, CategoryData>): string {
  const sortedCategories = Array.from(categories.values()).sort((a, b) =>
    a.folder.localeCompare(b.folder)
  );

  let content = "// This file is auto-generated by script/generate-unions.ts\n";
  content += "// Do not edit manually - run 'bun run sync-unions' to regenerate\n\n";

  // Generate imports grouped by category
  for (const category of sortedCategories) {
    if (category.interfaces.length === 0) continue;

    content += `import type {\n`;
    for (const interfaceName of category.interfaces.sort()) {
      content += `  ${interfaceName},\n`;
    }
    content += `} from "./tags/${category.folder}/index.js";\n\n`;
  }

  content += "/**\n * Union type of all possible tag instances.\n";
  content += " * This replaces the old string-based Tag type.\n */\n";
  content += "export type Tag =\n";

  // Generate union grouped by category with comments
  let isFirst = true;
  for (const category of sortedCategories) {
    if (category.interfaces.length === 0) continue;

    const categoryName = category.folder
      .split("-")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" ");

    content += `  // ${categoryName} tags\n`;
    for (const interfaceName of category.interfaces.sort()) {
      const prefix = isFirst ? "  " : "  | ";
      content += `${prefix}${interfaceName}\n`;
      isFirst = false;
    }
  }

  content += ";\n";

  return content;
}

/**
 * Main function
 */
async function main() {
  console.log("Scanning tag files...");
  const categories = await scanTagFiles();

  console.log(`Found ${categories.size} categories:`);
  for (const [folder, data] of categories) {
    console.log(
      `  - ${folder}: ${data.enumTypes.length} enum types, ${data.interfaces.length} interfaces`
    );
  }

  console.log("\nGenerating tag-type-union.ts...");
  const tagTypeUnion = generateTagTypeUnion(categories);
  await Deno.writeTextFile("./src/tag-type-union.ts", tagTypeUnion);

  console.log("Generating tag-interface-union.ts...");
  const tagInterfaceUnion = generateTagInterfaceUnion(categories);
  await Deno.writeTextFile("./src/tag-interface-union.ts", tagInterfaceUnion);

  console.log("\nâœ… Union files generated successfully!");
  console.log("   - src/tag-type-union.ts");
  console.log("   - src/tag-interface-union.ts");
}

if (import.meta.main) {
  main().catch((error) => {
    console.error("Error:", error);
    Deno.exit(1);
  });
}
